<!DOCTYPE html>
<html>

<head>
    <meta charset=utf-8>
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <title>Pathfinding</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Lato&display=swap" rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>
    <div id="header">
        <img width="200px"
            src="https://se-images.campuslabs.com/clink/images/f5e3ebdd-61b2-4be3-8337-d55490a87cc3691c5344-5614-4b02-805f-8ebba326b8ac.jpg" />
        <h1>Preference-Based Path Planning for Autonomous Robots</h1>
        <h3></h3>
        <h3>Ayden Shankman (EE '23'), Gavri Kepets (EE '23'), and Netanel Fiorino (ME '23')</h3>
        <h3>Senior Capstone Project Advised by Professor Carl Sable and Professor Michelle Rosen</h3>
    </div>
    <div id="canvaswrapper">
        <script type="importmap">
            {
            "imports": {
             "three": "https://cdn.skypack.dev/three/build/three.module",
                "three/": "https://cdn.skypack.dev/three/"    
            }
           }
          </script>
        <script type="module">
            import * as THREE from 'three';
            import {
                OrbitControls
            } from 'three/examples/jsm/controls/OrbitControls';
            window.addEventListener('resize', onWindowResize, false);
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(0, 1, 0); //default; light shining from top
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            directionalLight.castShadow = true

            let width = 47
            let height = 47
            const camera = new THREE.OrthographicCamera(width / - 2, width / 2, height / 2, height / - 2, 0.1, 1000);
            camera.position.set(1, 20, 30);
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth / 2, window.innerHeight / 2);
            onWindowResize();
            document.getElementById("canvaswrapper").appendChild(renderer.domElement);


            camera.position.z = 5;

            var controls = new OrbitControls(camera, renderer.domElement);
            controls.rotateSpeed = .7;
            controls.enableDamping = true;
            controls.dampingFactor = .05;
            controls.enableZoom = false;
            controls.maxPolarAngle = Math.PI / 2;
            controls.minPolarAngle = Math.PI / 6;

            generateMap();
            function animate() {
                requestAnimationFrame(animate);
                controls.update();

                renderer.render(scene, camera);
            }
            animate();



            function onWindowResize() {
                camera.aspect = 1;
                camera.updateProjectionMatrix();
                let size = Math.min(window.innerWidth, window.innerHeight) / 1.5;
                renderer.setSize(Math.floor(size), Math.floor(size));
            }

            function generateMap() {
                let terrainData = []
                for (let i = -16; i < 16; i++) {
                    for (let j = -16; j < 16; j++) {
                        terrainData.push({ x: i, y: j, z: Math.random() })
                    }
                }
                let minHeight = terrainData[0].z
                for (let i = 0; i < terrainData.length; i++) {
                    if (terrainData[i].z <= minHeight) {
                        minHeight = terrainData[i].z
                    }
                }

                minHeight -= 0.001
                let box_mat = new THREE.MeshStandardMaterial({ color: 0xfffffff })

                terrainData.map(cell => {
                    let height = (cell.z + Math.abs(minHeight)) * 3
                    let box = new THREE.Mesh(
                        new THREE.BoxGeometry(1, height, 1),
                        box_mat
                    );
                    box.castShadow = true; //default is false
                    box.receiveShadow = false;

                    scene.add(box);
                    box.position.set(cell.x, (height / 2), cell.y)

                    // var outlineMaterial1 = new THREE.MeshBasicMaterial({ color: 0x000000, wireframe: true });
                    // var outlineMesh1 = new THREE.Mesh(new THREE.BoxGeometry(1, height, 1), outlineMaterial1);
                    // scene.add(outlineMesh1);
                    // outlineMesh1.position.set(cell.x, (height / 2), cell.y)
                })
            }
        </script>
    </div>
    <div id="content">
        <div>
            <h3>The Problem</h3>
            <p>Today, autonomous robots are used in a variety of applications, including exploration, search and rescue,
                manufacturing, and military operations. For any autonomous robot to travel efficiently, it must use a
                path-finding algorithm to determine the best path based on certain criteria, most commonly being <span
                    style="color:blue; font-weight: bold;">SPEED</span>, <span
                    style="color:red; font-weight: bold;">SAFETY</span>, or <span
                    style="color:green; font-weight: bold;">ENERGY</span>. However, most autonomous robots today are
                catered to very specific environments and tasks, so the path-finding algorithms they deploy only cater
                to one criterion, such as the Mars Rover, which prioritizes safety. Some robots might want to prioritize
                a combination of the three criteria when looking for paths, but currently, there are no algorithms that
                handle this task in a way that is generalizable to any type of autonomous robot.</p>
        </div>
        <div>
            <h3>The Solution</h3>
            <p>
                Our algorithm would take in a robot's specifications, such as its dimensions speed/energy vs incline,
                maximum step up and down, etc., as well as the user's preference of how much to prioritize <span
                    style="color:blue; font-weight: bold;">SPEED</span>, <span
                    style="color:red; font-weight: bold;">SAFETY</span>, and <span
                    style="color:green; font-weight: bold;">ENERGY</span>. The user would then input a location for the
                robot to travel to, and the algorithm would generate a path that caters to the desired preferences.
            </p>
        </div>
    </div>
</body>

</html>